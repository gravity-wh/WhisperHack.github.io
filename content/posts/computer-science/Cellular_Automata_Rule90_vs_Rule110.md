

在刷HDLBits-摩尔电路部分的过程中接触到了这两种元胞自动机规则，简单了解了之后发现这背后别有洞天，并行计算的过程特别适合放在FPGA上跑，因此专门开篇文章研究一下。

在文章开始之前，我需要先明确一些定义：

- 元胞自动机：一种离散模型，由规则定义的网格状空间中的单元（元胞）组成，每个单元可以处于有限数量的状态之一。元胞的状态根据其邻居的状态和预定义的规则在离散时间步骤中更新。
- 图灵完备：系统能够模拟任意算法的能力。一个图灵完备的系统可以执行任何可计算的函数，前提是有足够的时间和存储空间。
- 分形与自相似性（Fractals）：分形是具有复杂结构的几何形状，其特点是在不同尺度下显示出自相似性。自相似性意味着分形的某些部分在放大后与整体形状相似。
- 计算不可约（computational irreduciblity）：某些系统的未来状态无法通过简化的规则或公式预测，必须通过逐步模拟其演化过程来确定。

## Rule 90
Rule 90 是一种一维元胞自动机，其更新规则基于每个单元及其两个邻居的当前状态。具体来说，Rule 90 的规则如下：
- 如果一个单元的左邻居和右邻居的状态不同（一个是1，另一个是0），则该单元在下一时间步骤中变为1。
- 如果一个单元的左邻居和右邻居的状态相同（都是0或都是1），则该单元在下一时间步骤中变为0。       
Rule 90 的更新规则可以用以下真值表表示：
| 左邻居 | 当前单元 | 右邻居 | 下一状态 |
|--------|----------|--------|----------|
|   0    |    0     |   0    |    0     |
|   0    |    0     |   1    |    1     |
|   0    |    1     |   0    |    1     |
|   0    |    1     |   1    |    0     |
|   1    |    0     |   0    |    1     |
|   1    |    0     |   1    |    0     |
|   1    |    1     |   0    |    0     |
|   1    |    1     |   1    |    1     |
Rule 90 的二进制表示为01011010，对应十进制数90。Rule 90 以其生成的分形图案（如Sierpinski三角形）而闻名，展示了简单规则如何产生复杂结构。

我猜想Markdown里应该会有合适的绘制方式区绘制制Rule90的演化过程：
```plaintext
Generation 0:          1
Generation 1:         101
Generation 2:        10001
Generation 3:       1000001
Generation 4:      100000001
Generation 5:     10000000001
```

## Rule 110
Rule 110 是另一种一维元胞自动机，其更新规则也基于每个单元及
Rule 110 的更新规则可以用以下真值表表示：
| 左邻居 | 当前单元 | 右邻居 | 下一状态 |
|--------|----------|--------|----------|
|   0    |    0     |   0    |    0     |
|   0    |    0     |   1    |    1     |
|   0    |    1     |   0    |    1     |
|   0    |    1     |   1    |    1     |
|   1    |    0     |   0    |    0     |
|   1    |    0     |   1    |    1     |
|   1    |    1     |   0    |    1     |
|   1    |    1     |   1    |    0     |
Rule 110 的二进制表示为01101110，对应十进制数110。Rule 110 以其图灵完备性而闻名，这意味着它能够模拟任何计算过程，前提是有足够的时间和空间。

### turning complete
Rule 110 的图灵完备性是由Stephen Wolfram在其著作《A New Kind of Science》中提出的。他证明了通过适当的初始条件，Rule 110 可以模拟任何图灵机的行为。这一发现表明，即使是非常简单的规则也可以产生极其复杂的计算能力。

举个例子:
假设我们想模拟二进制加法的计算过程。通过设计特定的初始状态，我们可以让 Rule 110 的演化过程模拟二进制加法器的行为。

具体来说，我们可以将两个二进制数编码为元胞的初始状态，然后通过 Rule 110 的演化来计算它们的和。

Rule 110 的演化过程如下所示：
```plaintext    
Generation 0:          1
Generation 1:         111
Generation 2:        11011
Generation 3:       1101011
Generation 4:      110100111
Generation 5:     11010010111
``` 
## 对比分析
1. 规则复杂性： Rule 90 的规则相对简单，仅涉及邻居状态的异或操作，而 Rule 110 的规则更复杂，涉及多种邻居状态组合。
2. 图案生成： Rule 90 生成的图案具有明显的分形
3. 图灵完备性： Rule 110 是图灵完备的，意味着它可以模拟任何计算过程，而 Rule 90 则不具备这种能力。
4. 计算不可约性： Rule 110 展示了计算不可约性的概念，即其未来状态无法通过简化的规则预测，必须通过逐步模拟其演化过程来确定。Rule 90 则相对容易预测其演化过程。
5. 应用领域： Rule 90 常用于生成分形图案和研究自相似性，而 Rule 110 则在计算理论和复杂系统研究中具有重要意义。
6. 邻居依赖性： Rule 90 的更新仅依赖于左右邻居的状态，而 Rule 110 的更新规则更复杂，涉及更多的邻居状态组合。
7. 初始条件敏感性： Rule 110 对初始条件非常敏感，不同的初始状态可能导致完全不同的演化路径，而 Rule 90 的演化相对稳定。
8. 计算能力： Rule 110 的图灵完备性使其能够执行复杂的计算任务，而 Rule 90 的计算能力有限，主要用于生成特定的图案。

## 参考资料

[Rule 110 -- from Wolfram MathWorld](https://mathworld.wolfram.com/Rule110.html)

[Rule 90 -- from Wolfram MathWorld](https://mathworld.wolfram.com/Rule90.html)

[Cellular automata rule 90 and the Sierpinski triangle](https://www.johndcook.com/blog/2017/09/23/sierpinski-triangle-strikes-again/)

[Elementary cellular automaton - Rosetta Code](https://rosettacode.org/wiki/Elementary_cellular_automaton)

[Rule 110 - Wikipedia](https://en.wikipedia.org/wiki/Rule_110)

[Rule 90 - Wikipedia](https://en.wikipedia.org/wiki/Rule_90)
